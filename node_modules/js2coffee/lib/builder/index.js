// Generated by CoffeeScript 1.10.0
(function() {
  var Builder, BuilderBase, TransformerBase, commaDelimit, delimit, joinLines, newline, prependAll, quote, ref, space, toIndent,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('../helpers'), prependAll = ref.prependAll, quote = ref.quote, newline = ref.newline, space = ref.space, delimit = ref.delimit, commaDelimit = ref.commaDelimit, toIndent = ref.toIndent, joinLines = ref.joinLines;

  TransformerBase = require('../transforms/base');

  BuilderBase = require('./base');


  /**
   * Builder : new Builder(ast, [options])
   * Generates output based on a JavaScript AST.
   *
   *     s = new Builder(ast, { filename: 'input.js', source: '...' })
   *     s.get()
   *     => { code: '...', map: { ... } }
   *
   * The params `options` and `source` are optional. The source code is used to
   * generate meaningful errors.
   */

  module.exports = Builder = (function(superClass) {
    extend(Builder, superClass);

    function Builder(ast, options) {
      if (options == null) {
        options = {};
      }
      Builder.__super__.constructor.apply(this, arguments);
      this._indent = 0;
    }


    /**
     * visitors:
     * The visitors of each node.
     */

    Builder.prototype.Program = function(node) {
      this.comments = node.comments;
      return this.BlockStatement(node);
    };

    Builder.prototype.ExpressionStatement = function(node) {
      return newline(this.walk(node.expression));
    };

    Builder.prototype.AssignmentExpression = function(node) {
      var re;
      re = this.paren(space([this.walk(node.left), node.operator, this.walk(node.right)]));
      if (node.right.type === 'FunctionExpression') {
        re = ["\n", this.indent(), re, "\n"];
      }
      return re;
    };

    Builder.prototype.Identifier = function(node) {
      return [node.name];
    };

    Builder.prototype.UnaryExpression = function(node) {
      var isNestedUnary, isWord;
      isNestedUnary = function() {
        return node.argument.type === 'UnaryExpression';
      };
      isWord = function() {
        return /^[a-z]+$/i.test(node.operator);
      };
      if (isNestedUnary() || isWord()) {
        return this.paren([node.operator, ' ', this.walk(node.argument)]);
      } else {
        return this.paren([node.operator, this.walk(node.argument)]);
      }
    };

    Builder.prototype.BinaryExpression = function(node) {
      var operator;
      operator = node.operator;
      if (operator === 'in') {
        operator = 'of';
      }
      return this.paren(space([this.walk(node.left), operator, this.walk(node.right)]));
    };

    Builder.prototype.Literal = function(node) {
      if (typeof node.value === 'string') {
        return [quote(node.value)];
      } else {
        return [node.raw];
      }
    };

    Builder.prototype.MemberExpression = function(node) {
      var right;
      right = node.computed ? ['[', this.walk(node.property), ']'] : node._prefixed ? [this.walk(node.property)] : ['.', this.walk(node.property)];
      return this.paren([this.walk(node.object), right]);
    };

    Builder.prototype.LogicalExpression = function(node) {
      var oper, opers;
      opers = {
        '||': 'or',
        '&&': 'and'
      };
      oper = opers[node.operator];
      return this.paren([this.walk(node.left), ' ', oper, ' ', this.walk(node.right)]);
    };

    Builder.prototype.ThisExpression = function(node) {
      if (node._prefix) {
        return ["@"];
      } else {
        return ["this"];
      }
    };

    Builder.prototype.CallExpression = function(node, ctx) {
      var callee, hasArgs, list;
      callee = this.walk(node.callee);
      list = this.makeSequence(node["arguments"]);
      node._isStatement = ctx.parent.type === 'ExpressionStatement';
      hasArgs = list.length > 0;
      if (node._isStatement && hasArgs) {
        return space([callee, list]);
      } else {
        return [callee, this.paren(list, true)];
      }
    };

    Builder.prototype.IfStatement = function(node) {
      var alt, els;
      alt = node.alternate;
      if ((alt != null ? alt.type : void 0) === 'IfStatement') {
        els = this.indent(["else ", this.walk(node.alternate, 'IfStatement')]);
      } else if ((alt != null ? alt.type : void 0) === 'BlockStatement') {
        els = this.indent((function(_this) {
          return function(i) {
            return [i, "else", "\n", _this.walk(node.alternate)];
          };
        })(this));
      } else if (alt != null) {
        els = this.indent((function(_this) {
          return function(i) {
            return [i, "else", "\n", _this.indent(_this.walk(node.alternate))];
          };
        })(this));
      } else {
        els = [];
      }
      return this.indent((function(_this) {
        return function(i) {
          var consequent, test, word;
          test = _this.walk(node.test);
          consequent = _this.walk(node.consequent);
          if (node.consequent.type !== 'BlockStatement') {
            consequent = _this.indent(consequent);
          }
          word = node._negative ? 'unless' : 'if';
          return [word, ' ', test, "\n", consequent, els];
        };
      })(this));
    };

    Builder.prototype.BlockStatement = function(node) {
      return this.makeStatements(node, node.body);
    };

    Builder.prototype.makeStatements = function(node, body) {
      return prependAll(body.map(this.walk), this.indent());
    };

    Builder.prototype.LineComment = function(node) {
      return ["#", node.value, "\n"];
    };

    Builder.prototype.BlockComment = function(node) {
      var lines, output;
      lines = ('###' + node.value + '###').split("\n");
      output = [delimit(lines, ["\n", this.indent()]), "\n"];
      return ["\n", this.indent(), output, "\n"];
    };

    Builder.prototype.ReturnStatement = function(node) {
      if (node.argument) {
        return space(["return", [this.walk(node.argument), "\n"]]);
      } else {
        return ["return", "\n"];
      }
    };

    Builder.prototype.ArrayExpression = function(node) {
      var isSingleLine, items;
      items = node.elements.length;
      isSingleLine = items === 1;
      if (items === 0) {
        return ["[]"];
      } else if (isSingleLine) {
        return space(["[", node.elements.map(this.walk), "]"]);
      } else {
        return this.indent((function(_this) {
          return function(indent) {
            var contents, elements;
            elements = node.elements.map(function(e) {
              return newline(_this.walk(e));
            });
            contents = prependAll(elements, _this.indent());
            return ["[", "\n", contents, indent, "]"];
          };
        })(this));
      }
    };

    Builder.prototype.ObjectExpression = function(node, ctx) {
      var isBraced, props;
      props = node.properties.length;
      isBraced = node._braced;
      if (props === 0) {
        return ["{}"];
      } else if (props === 1) {
        props = node.properties.map(this.walk);
        if (isBraced) {
          return this.paren(space(["{", props, "}"]));
        } else {
          return this.paren([props]);
        }
      } else if (node._last) {
        props = node.properties.map(this.walk);
        return delimit(props, ["\n", this.indent()]);
      } else {
        props = this.indent((function(_this) {
          return function() {
            props = node.properties.map(_this.walk);
            return ["\n", joinLines(props, _this.indent())];
          };
        })(this));
        if (isBraced) {
          return this.paren(["{", props, "\n", this.indent(), "}"]);
        } else {
          return this.paren([props]);
        }
      }
    };

    Builder.prototype.Property = function(node) {
      if (node.kind !== 'init') {
        throw new Error("Property: not sure about kind " + node.kind);
      }
      return space([[this.walk(node.key), ":"], this.walk(node.value)]);
    };

    Builder.prototype.VariableDeclaration = function(node) {
      var declarators;
      declarators = node.declarations.map(this.walk);
      return delimit(declarators, this.indent());
    };

    Builder.prototype.VariableDeclarator = function(node) {
      var re;
      re = [this.walk(node.id), ' = ', newline(this.walk(node.init))];
      if (node.init.type === 'FunctionExpression') {
        re = ["\n", this.indent(), re, "\n"];
      }
      return re;
    };

    Builder.prototype.FunctionExpression = function(node, ctx) {
      var expr, params;
      params = this.makeParams(node.params, node.defaults);
      expr = this.indent((function(_this) {
        return function(i) {
          return [params, "->", "\n", _this.walk(node.body)];
        };
      })(this));
      if (node._parenthesized) {
        return ["(", expr, this.indent(), ")"];
      } else {
        return expr;
      }
    };

    Builder.prototype.EmptyStatement = function(node) {
      return [];
    };

    Builder.prototype.SequenceExpression = function(node) {
      var exprs;
      exprs = node.expressions.map((function(_this) {
        return function(expr) {
          return [_this.walk(expr), "\n"];
        };
      })(this));
      return delimit(exprs, this.indent());
    };

    Builder.prototype.NewExpression = function(node) {
      var args, callee, ref1, ref2;
      callee = ((ref1 = node.callee) != null ? ref1.type : void 0) === 'Identifier' ? [this.walk(node.callee)] : ['(', this.walk(node.callee), ')'];
      args = ((ref2 = node["arguments"]) != null ? ref2.length : void 0) ? ['(', this.makeSequence(node["arguments"]), ')'] : [];
      return this.paren(["new ", callee, args]);
    };

    Builder.prototype.WhileStatement = function(node) {
      return ["while ", this.walk(node.test), "\n", this.makeLoopBody(node.body)];
    };

    Builder.prototype.CoffeeLoopStatement = function(node) {
      return ["loop", "\n", this.makeLoopBody(node.body)];
    };

    Builder.prototype.BreakStatement = function(node) {
      return ["break", "\n"];
    };

    Builder.prototype.ContinueStatement = function(node) {
      return ["continue", "\n"];
    };

    Builder.prototype.DebuggerStatement = function(node) {
      return ["debugger", "\n"];
    };

    Builder.prototype.TryStatement = function(node) {
      var _catch, _finally, _try;
      _try = this.indent((function(_this) {
        return function() {
          return ["try", "\n", _this.walk(node.block)];
        };
      })(this));
      _catch = prependAll(node.handlers.map(this.walk), this.indent());
      _finally = node.finalizer != null ? this.indent((function(_this) {
        return function(indent) {
          return [indent, "finally", "\n", _this.walk(node.finalizer)];
        };
      })(this)) : [];
      return [_try, _catch, _finally];
    };

    Builder.prototype.CatchClause = function(node) {
      return this.indent((function(_this) {
        return function() {
          return ["catch ", _this.walk(node.param), "\n", _this.walk(node.body)];
        };
      })(this));
    };

    Builder.prototype.ThrowStatement = function(node) {
      return ["throw ", this.walk(node.argument), "\n"];
    };

    Builder.prototype.ConditionalExpression = function(node) {
      return this.paren(space(["if", this.walk(node.test), "then", this.walk(node.consequent), "else", this.walk(node.alternate)]));
    };

    Builder.prototype.UpdateExpression = function(node) {
      if (node.prefix) {
        return [node.operator, this.walk(node.argument)];
      } else {
        return [this.walk(node.argument), node.operator];
      }
    };

    Builder.prototype.SwitchStatement = function(node) {
      var body, item;
      body = this.indent((function(_this) {
        return function() {
          return _this.makeStatements(node, node.cases);
        };
      })(this));
      item = this.walk(node.discriminant);
      if (node.discriminant.type === 'ConditionalExpression') {
        item = ["(", item, ")"];
      }
      return ["switch ", item, "\n", body];
    };

    Builder.prototype.CoffeeListExpression = function(node) {
      return this.makeSequence(node.expressions);
    };

    Builder.prototype.SwitchCase = function(node) {
      var left, right;
      left = node.test ? ["when ", this.walk(node.test)] : ["else"];
      right = this.indent((function(_this) {
        return function() {
          return _this.makeStatements(node, node.consequent);
        };
      })(this));
      return [left, "\n", right];
    };

    Builder.prototype.ForInStatement = function(node) {
      var body, id, propagator;
      if (node.left.type !== 'VariableDeclaration') {
        id = this.walk(node.left);
        propagator = {
          type: 'ExpressionStatement',
          expression: {
            type: 'CoffeeEscapedExpression',
            raw: id + " = " + id
          }
        };
        node.body.body = [propagator].concat(node.body.body);
      } else {
        id = this.walk(node.left.declarations[0].id);
      }
      body = this.makeLoopBody(node.body);
      return ["for ", id, " of ", this.walk(node.right), "\n", body];
    };

    Builder.prototype.makeLoopBody = function(body) {
      var isBlock;
      isBlock = (body != null ? body.type : void 0) === 'BlockStatement';
      if (!body || (isBlock && body.body.length === 0)) {
        return this.indent((function(_this) {
          return function() {
            return [_this.indent(), "continue", "\n"];
          };
        })(this));
      } else if (isBlock) {
        return this.indent((function(_this) {
          return function() {
            return _this.walk(body);
          };
        })(this));
      } else {
        return this.indent((function(_this) {
          return function() {
            return [_this.indent(), _this.walk(body)];
          };
        })(this));
      }
    };

    Builder.prototype.CoffeeEscapedExpression = function(node) {
      if (node._parenthesized) {
        return ['(`', node.raw, '`)'];
      } else {
        return ['`', node.raw, '`'];
      }
    };

    Builder.prototype.CoffeePrototypeExpression = function(node) {
      if (node.computed) {
        return [this.walk(node.object), '::[', this.walk(node.property), ']'];
      } else {
        return [this.walk(node.object), '::', this.walk(node.property)];
      }
    };

    Builder.prototype.CoffeeDoExpression = function(node) {
      return space(['do', this.walk(node["function"])]);
    };


    /**
     * makeSequence():
     * Builds a comma-separated sequence of nodes.
     * TODO: turn this into a transformation
     */

    Builder.prototype.makeSequence = function(list) {
      var arg, i, isLast, j, len;
      for (i = j = 0, len = list.length; j < len; i = ++j) {
        arg = list[i];
        isLast = i === (list.length - 1);
        if (!isLast) {
          if (arg.type === "FunctionExpression") {
            arg._parenthesized = true;
          } else if (arg.type === "ObjectExpression") {
            arg._braced = true;
          }
        }
      }
      return commaDelimit(list.map(this.walk));
    };


    /**
     * makeParams():
     * Builds parameters for a function list.
     */

    Builder.prototype.makeParams = function(params, defaults) {
      var def, i, j, len, list, param;
      list = [];
      for (i = j = 0, len = params.length; j < len; i = ++j) {
        param = params[i];
        if (defaults[i]) {
          def = this.walk(defaults[i]);
          list.push([this.walk(param), ' = ', def]);
        } else {
          list.push(this.walk(param));
        }
      }
      if (params.length) {
        return ['(', delimit(list, ', '), ') '];
      } else {
        return [];
      }
    };


    /**
     * In a call expression, ensure that non-last function arguments get
     * parenthesized (eg, `setTimeout (-> x), 500`).
     */

    Builder.prototype.parenthesizeArguments = function(node) {
      var arg, i, isLast, j, len, ref1, results;
      ref1 = node["arguments"];
      results = [];
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        arg = ref1[i];
        isLast = i === (node["arguments"].length - 1);
        if (arg.type === "FunctionExpression") {
          if (!isLast) {
            results.push(arg._parenthesized = true);
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /*
     * Utilities
     */


    /**
     * indent():
     * Indentation utility with 3 different functions.
     *
     * - `@indent(-> ...)` - adds an indent level.
     * - `@indent([ ... ])` - adds indentation.
     * - `@indent()` - returns the current indent level as a string.
     *
     * When invoked with a function, the indentation level is increased by 1, and
     * the function is invoked. This is similar to escodegen's `withIndent`.
     *
     *     @indent =>
     *       [ '...' ]
     *
     * The past indent level is passed to the function as the first argument.
     *
     *     @indent (indent) =>
     *       [ indent, 'if', ... ]
     *
     * When invoked with an array, it will indent it.
     *
     *     @indent [ 'if...' ]
     *     #=> [ '  ', [ 'if...' ] ]
     *
     * When invoked without arguments, it returns the current indentation as a
     * string.
     *
     *     @indent()
     */

    Builder.prototype.indent = function(fn) {
      var previous, result, tab;
      if (typeof fn === "function") {
        previous = this.indent();
        this._indent += 1;
        result = fn(previous);
        this._indent -= 1;
        return result;
      } else if (fn) {
        return [this.indent(), fn];
      } else {
        tab = toIndent(this.options.indent);
        return Array(this._indent + 1).join(tab);
      }
    };


    /**
     * paren():
     * Parenthesizes if the node's parenthesize flag is on (or `parenthesized` is
     * true)
     */

    Builder.prototype.paren = function(output, parenthesized) {
      var isBlock, ref1;
      if (parenthesized == null) {
        parenthesized = (ref1 = this.path[this.path.length - 1]) != null ? ref1._parenthesized : void 0;
      }
      isBlock = output.toString().match(/\n$/);
      if (parenthesized) {
        if (isBlock) {
          return ['(', output, this.indent(), ')'];
        } else {
          return ['(', output, ')'];
        }
      } else {
        return output;
      }
    };


    /**
     * onUnknownNode():
     * Invoked when the node is not known. Throw an error.
     */

    Builder.prototype.onUnknownNode = function(node, ctx) {
      return this.syntaxError(node, node.type + " is not supported");
    };

    Builder.prototype.syntaxError = TransformerBase.prototype.syntaxError;

    return Builder;

  })(BuilderBase);

}).call(this);

//# sourceMappingURL=index.js.map
