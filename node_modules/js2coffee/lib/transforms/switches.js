// Generated by CoffeeScript 1.10.0
(function() {
  var TransformerBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TransformerBase = require('./base.coffee');


  /*
   * Updates `SwitchCase`s to a more coffee-compliant AST. This means having
   * to remove `return`/`break` statements, and taking into account the
   * correct way of consolidating empty ccases.
   *
   *     switch (x) { case a: b(); break; }
   *
   *     switch x
   *       when a then b()
   */

  module.exports = (function(superClass) {
    extend(_Class, superClass);

    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.SwitchStatement = function(node) {
      this.consolidateCases(node);
      return this.ensureLastCaseIsDefault(node);
    };

    _Class.prototype.SwitchCase = function(node) {
      return this.removeBreaksFromConsequents(node);
    };


    /*
     * Ensure that `default:` is only at the end.
     */

    _Class.prototype.ensureLastCaseIsDefault = function(node) {
      var cases, i, isDefault, isLast, j, kase, last, len;
      cases = node.cases.filter(function(c) {
        return c.type === 'SwitchCase';
      });
      last = cases.length;
      for (i = j = 0, len = cases.length; j < len; i = ++j) {
        kase = cases[i];
        isLast = i === last - 1;
        isDefault = kase.test == null;
        if (isDefault && !isLast) {
          this.syntaxError(kase, "default cases only allowed at the end");
        }
      }
      return node;
    };


    /*
     * Consolidates empty cases into the next case. The case tests will then be
     * made into a new node type, CoffeeListExpression, to represent
     * comma-separated values. (`case x: case y: z()` => `case x, y: z()`)
     */

    _Class.prototype.consolidateCases = function(node) {
      var i, j, kase, len, list, ref, toConsolidate;
      list = [];
      toConsolidate = [];
      ref = node.cases;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        kase = ref[i];
        if (kase.type === 'SwitchCase') {
          if (kase.test) {
            toConsolidate.push(kase.test);
          }
          if (kase.consequent.length > 0) {
            if (kase.test) {
              kase.test = {
                type: 'CoffeeListExpression',
                expressions: toConsolidate
              };
            }
            toConsolidate = [];
            list.push(kase);
          }
        } else {
          list.push(kase);
        }
      }
      node.cases = list;
      return node;
    };


    /*
     * Removes `break` statements from consequents in a switch case.
     * (eg, `case x: a(); break;` gets break; removed)
     */

    _Class.prototype.removeBreaksFromConsequents = function(node) {
      var idx, last;
      if (node.test) {
        idx = node.consequent.length - 1;
        last = node.consequent[idx];
        if ((last != null ? last.type : void 0) === 'BreakStatement') {
          delete node.consequent[idx];
          node.consequent.length -= 1;
        } else if ((last != null ? last.type : void 0) === 'ContinueStatement') {

        } else if ((last != null ? last.type : void 0) !== 'ReturnStatement') {
          this.syntaxError(node, "No break or return statement found in a case");
        }
        return node;
      }
    };

    return _Class;

  })(TransformerBase);

}).call(this);

//# sourceMappingURL=switches.js.map
