// Generated by CoffeeScript 1.10.0
(function() {
  var TransformerBase, isLoop, ref, replace,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('../helpers'), replace = ref.replace, isLoop = ref.isLoop;

  TransformerBase = require('./base');


  /*
   * Provides transformations for `while`, `for` and `do`.
   */

  module.exports = (function(superClass) {
    extend(_Class, superClass);

    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.ForStatement = function(node) {
      if (this._for == null) {
        this._for = [];
      }
      this._for.push(node);
      this.injectUpdateIntoBody(node);
      return this.convertForToWhile(node);
    };

    _Class.prototype.ForStatementExit = function(node) {
      var _for;
      _for = this._for.pop();
      delete _for._update;
      return node;
    };

    _Class.prototype.ForInStatement = function(node) {
      return this.warnIfNoVar(node);
    };

    _Class.prototype.WhileStatement = function(node) {
      return this.convertWhileToLoop(node);
    };

    _Class.prototype.DoWhileStatement = function(node) {
      return this.convertDoWhileToLoop(node);
    };

    _Class.prototype.ContinueStatement = function(node, parent) {
      return this.injectUpdateIntoContinue(node, parent);
    };


    /*
     * In a `for` loop with an update statement, inject the update just
     * before the `continue`.
     *
     * This replaces the ContinueStatement with a block that groups the
     * update and continue together.
     */

    _Class.prototype.injectUpdateIntoContinue = function(node, parent) {
      var _for, ref1;
      _for = (ref1 = this._for) != null ? ref1[this._for.length - 1] : void 0;
      if (!(_for != null ? _for._update : void 0)) {
        return node;
      }
      this.skip();
      return {
        type: 'BlockStatement',
        body: [
          {
            type: 'ExpressionStatement',
            expression: _for._update
          }, node
        ]
      };
    };


    /*
     * Converts `do { x } while (y)` to `loop\  x\  break unless y`.
     */

    _Class.prototype.convertDoWhileToLoop = function(node) {
      var block, body;
      block = node.body;
      body = block.body;
      body.push(replace(node.test, {
        type: 'IfStatement',
        _negative: true,
        test: node.test,
        consequent: {
          type: 'BreakStatement'
        }
      }));
      return replace(node, {
        type: 'CoffeeLoopStatement',
        body: block
      });
    };


    /*
     * Produce a warning for `for (x in y)` where `x` is not `var x`.
     */

    _Class.prototype.warnIfNoVar = function(node) {
      if (node.left.type !== 'VariableDeclaration') {
        this.warn(node, "Using 'for..in' loops without " + "'var' can produce unexpected results");
      }
      return node;
    };


    /*
     * Converts a `for (x;y;z) {a}` to `x; while(y) {a; z}`.
     * Returns a `BlockStatement`.
     */

    _Class.prototype.convertForToWhile = function(node) {
      node.type = isLoop(node) ? 'CoffeeLoopStatement' : 'WhileStatement';
      if (node.init != null) {
        return {
          type: 'BlockStatement',
          body: [
            {
              type: 'ExpressionStatement',
              expression: node.init
            }, node
          ]
        };
      } else {
        return node;
      }
    };


    /*
     * Converts a `while (true)` to a CoffeeLoopStatement.
     */

    _Class.prototype.convertWhileToLoop = function(node) {
      if (isLoop(node)) {
        return replace(node, {
          type: 'CoffeeLoopStatement',
          body: node.body
        });
      } else {
        return node;
      }
    };


    /**
     * Injects a ForStatement's update (eg, `i++`) into the body.
     */

    _Class.prototype.injectUpdateIntoBody = function(node) {
      var old, statement;
      if (node.update) {
        statement = {
          type: 'ExpressionStatement',
          expression: node.update
        };
        if (node.body == null) {
          if (node.body == null) {
            node.body = {
              type: 'BlockStatement',
              body: []
            };
          }
        } else if (node.body.type !== 'BlockStatement') {
          old = node.body;
          node.body = {
            type: 'BlockStatement',
            body: [old]
          };
        }
        node.body.body = node.body.body.concat([statement]);
        node._update = node.update;
        delete node.update;
      }
      return node;
    };

    return _Class;

  })(TransformerBase);

}).call(this);

//# sourceMappingURL=loops.js.map
