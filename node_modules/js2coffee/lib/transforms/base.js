// Generated by CoffeeScript 1.10.0
(function() {
  var TransformerBase, buildError, chain, clone, ref, replace, safeExtend, toIndent,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require('../helpers'), buildError = ref.buildError, clone = ref.clone, replace = ref.replace, toIndent = ref.toIndent;


  /***
   * TransformerBase:
   * Base class of all transformation steps, such as [FunctionTransforms] and
   * [OtherTransforms]. This is a thin wrapper around *estraverse* to make things
   * easier, as well as to add extra features like scope tracking and more.
   *
   *     class MyTransform extends TransformerBase
   *       Program: (node) ->
   *         return { replacementNodeHere }
   *
   *       FunctionDeclaration: (node) ->
   *         ...
   *
   *     ctx = {}
   *     TransformerBase.run ast, options, [ MyTransform ], ctx
   *
   *     # result:
   *     ast
   *     ctx.warnings
   *
   * Each visitor is a method with the node type as the name.
   *
   *     class MyTransform extends TransformerBase
   *       Literal: (node) ->
   *         # do stuff with `node`
   *         # return the replacement when done
   *
   *       FunctionDeclaration: (node) ->
   *         # do stuff with `node` too
   *
   * From within the handlers, you can call some utility functions:
   *
   *     @skip()
   *     @break()
   *     @syntaxError(node, "'with' is not supported")
   *     @warn(node, "warning goes here")
   *
   * You have access to these variables:
   *
   * ~ @depth: The depth of the current node
   * ~ @node: The current node.
   * ~ @controller: The estraverse instance
   *
   * It also keeps track of scope. For every function body it traverses into (eg:
   * FunctionExpression.body), you get a `@ctx` variable that is only available
   * from *within that scope* and the scopes below it.
   *
   * ~ @scope: the Node that is the current scope. This is usually a BlockStatement
   *   or a Program.
   * ~ @ctx: Context variables for the scope. You can store anything here and it
   *   will be remembered for the current scope and the scopes below it.
   *
   * It also has a few hooks that you can override:
   *
   * ~ onScopeEnter: when scopes are entered (via `pushScope()`)
   * ~ onScopeExit: when scopes are exited (via `popScope()`)
   * ~ onEnter: enter of a node
   * ~ onExit: exit of a node
   * ~ onBeforeEnter: before the enter of a node
   * ~ onBeforeExit: before the exit of a node
   */

  module.exports = TransformerBase = (function() {

    /*
     * Run multiple transformations
     */
    TransformerBase.run = function(ast, options, classes, ctx) {
      var Xformer, result, xform;
      Xformer = (function(superClass) {
        extend(_Class, superClass);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        return _Class;

      })(TransformerBase);
      safeExtend(Xformer, classes);
      xform = new Xformer(ast, options);
      result = xform.run();
      if (ctx.warnings == null) {
        ctx.warnings = [];
      }
      ctx.warnings = ctx.warnings.concat(xform.warnings);
      return result;
    };

    function TransformerBase(ast1, options1) {
      this.ast = ast1;
      this.options = options1;
      this.scopes = [];
      this.ctx = {
        vars: []
      };
      this.warnings = [];
    }


    /**
     * run():
     * Runs estraverse on `@ast`, and invokes functions on enter and exit
     * depending on the node type. This is also in change of changing `@depth`,
     * `@node`, `@controller` (etc) every step of the way.
     *
     *     new Transformer(ast).run()
     */

    TransformerBase.prototype.run = function() {
      return this.recurse(this.ast);
    };


    /**
     * recurse():
     * Delegate function of `run()`. See [run()] for details.
     *
     * This is sometimes called on its own to recurse down a certain path which
     * will otherwise be skipped.
     */

    TransformerBase.prototype.recurse = function(root) {
      var runner, self;
      self = this;
      this.depth = 0;
      runner = (function(_this) {
        return function(direction, node, parent) {
          var fnName, name, name1, result;
          _this.node = node;
          _this.depth += direction === 'Enter' ? +1 : -1;
          fnName = direction === 'Enter' ? "" + node.type : node.type + "Exit";
          if (typeof _this[name = "onBefore" + direction] === "function") {
            _this[name](node, parent);
          }
          result = typeof _this[fnName] === "function" ? _this[fnName](node, parent) : void 0;
          if (typeof _this[name1 = "on" + direction] === "function") {
            _this[name1](node, parent);
          }
          return result;
        };
      })(this);
      this.estraverse().replace(root, {
        enter: function(node, parent) {
          self.controller = this;
          return runner("Enter", node, parent);
        },
        leave: function(node, parent) {
          return runner("Exit", node, parent);
        }
      });
      return root;
    };


    /**
     * skip():
     * Skips a certain node from being parsed.
     *
     *     class MyTransform extends TransformerBase
     *       Identifier: ->
     *         @skip()
     */

    TransformerBase.prototype.skip = function() {
      var ref1;
      return (ref1 = this.controller) != null ? ref1.skip() : void 0;
    };


    /**
     * remove():
     * Removes a node from the tree.
     *
     *     class MyTransform extends TransformerBase
     *       Identifier: ->
     *         @remove()
     */

    TransformerBase.prototype.remove = function() {
      var ref1;
      return (ref1 = this.controller) != null ? ref1.remove() : void 0;
    };


    /**
     * estraverse():
     * Returns `estraverse`. It's monkey-patched to work with CoffeeScript ASTs.
     *
     *     @estraverse().replace ast, ...
     */

    TransformerBase.prototype.estraverse = function() {
      return this._estraverse != null ? this._estraverse : this._estraverse = (function() {
        var es;
        es = require('estraverse');
        es.VisitorKeys.CoffeeEscapedExpression = [];
        es.VisitorKeys.CoffeeListExpression = ['test', 'body'];
        es.VisitorKeys.CoffeePrototypeExpression = ['object', 'property', 'computed'];
        es.VisitorKeys.CoffeeLoopStatement = ['body'];
        es.VisitorKeys.CoffeeDoExpression = ['function'];
        es.VisitorKeys.BlockComment = [];
        es.VisitorKeys.LineComment = [];
        return es;
      })();
    };


    /**
     * pushStack() : @pushStack(node)
     * Pushes a scope to the scope stack. Every time the scope changes, `@scope`
     * and `@ctx` gets changed.
     */

    TransformerBase.prototype.pushStack = function(node) {
      var oldCtx, oldScope, ref1;
      ref1 = [this.scope, this.ctx], oldScope = ref1[0], oldCtx = ref1[1];
      this.scopes.push([node, this.ctx]);
      this.ctx = clone(this.ctx);
      this.scope = node;
      return typeof this.onScopeEnter === "function" ? this.onScopeEnter(this.scope, this.ctx, oldScope, oldCtx) : void 0;
    };

    TransformerBase.prototype.popStack = function() {
      var oldCtx, oldScope, ref1, ref2;
      ref1 = [this.scope, this.ctx], oldScope = ref1[0], oldCtx = ref1[1];
      ref2 = this.scopes.pop(), this.scope = ref2[0], this.ctx = ref2[1];
      return typeof this.onScopeExit === "function" ? this.onScopeExit(this.scope, this.ctx, oldScope, oldCtx) : void 0;
    };


    /**
     * syntaxError() : @syntaxError(node, message)
     * Throws a syntax error for the given `node` with a given `message`.
     *
     *     @syntaxError node, "Not supported"
     */

    TransformerBase.prototype.syntaxError = function(node, description) {
      var err, ref1, ref2;
      err = buildError({
        start: (ref1 = node.loc) != null ? ref1.start : void 0,
        end: (ref2 = node.loc) != null ? ref2.end : void 0,
        description: description
      }, this.options.source, this.options.filename);
      throw err;
    };


    /**
     * warn() : @warn(node, message)
     * Add a warning
     *
     *     @warn node, "Variable was defined twice"
     */

    TransformerBase.prototype.warn = function(node, description) {
      var ref1, ref2;
      return this.warnings.push({
        start: (ref1 = node.loc) != null ? ref1.start : void 0,
        end: (ref2 = node.loc) != null ? ref2.end : void 0,
        filename: this.options.filename,
        description: description
      });
    };


    /**
     * Defaults: these are default handlers that will automatially change `@scope`.
     */

    TransformerBase.prototype.Program = function(node) {
      this.pushStack(node);
      return node;
    };

    TransformerBase.prototype.ProgramExit = function(node) {
      this.popStack();
      return node;
    };

    TransformerBase.prototype.FunctionExpression = function(node) {
      this.pushStack(node.body);
      return node;
    };

    TransformerBase.prototype.FunctionExpressionExit = function(node) {
      this.popStack();
      return node;
    };

    TransformerBase.prototype.escapeJs = function(node, options) {
      if (options == null) {
        options = {};
      }
      return replace(node, {
        type: 'CoffeeEscapedExpression',
        _parenthesized: options.parenthesized,
        raw: require('escodegen').generate(node, {
          format: {
            indent: {
              style: toIndent(this.options.indent)
            }
          }
        })
      });
    };

    return TransformerBase;

  })();


  /*
   * Extends a class `dest`'s prototype with those from other classes in `classes`.
   * Throws an error if there's a clash.
   */

  safeExtend = function(dest, classes) {
    var added;
    added = {};
    classes.forEach(function(klass) {
      var fn, key, ref1, results;
      ref1 = klass.prototype;
      results = [];
      for (key in ref1) {
        fn = ref1[key];
        if (klass.prototype.hasOwnProperty(key)) {
          if (added[key] && key !== 'constructor') {
            dest.prototype[key] = chain(dest.prototype[key], fn);
          } else {
            dest.prototype[key] = fn;
          }
          results.push(added[key] = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    });
    return dest;
  };

  chain = function(old, noo) {
    return function() {
      var args, node, result, type;
      node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      type = node.type;
      result = old.bind(this).apply(null, [node].concat(slice.call(args)));
      if (result.type === type) {
        result = noo.bind(this).apply(null, [result].concat(slice.call(args)));
      }
      return result;
    };
  };

}).call(this);

//# sourceMappingURL=base.js.map
