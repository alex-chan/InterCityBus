// Generated by CoffeeScript 1.10.0
(function() {
  var TransformerBase, quote, ref, replace, reservedWords,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('../helpers'), reservedWords = ref.reservedWords, replace = ref.replace, quote = ref.quote;

  TransformerBase = require('./base');


  /*
   * Mangles the AST with various CoffeeScript tweaks.
   */

  module.exports = (function(superClass) {
    extend(_Class, superClass);

    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.FunctionExpression = function(node, parent) {
      _Class.__super__.FunctionExpression.call(this, node);
      node.params.forEach((function(_this) {
        return function(param) {
          if (param.type === 'Identifier') {
            _this.ctx.vars.push(param.name);
          }
          return _this.preventReservedWords(param);
        };
      })(this));
      this.preventReservedWords(node.id);
      return this.removeUndefinedParameter(node);
    };

    _Class.prototype.CallExpression = function(node) {
      return this.parenthesizeCallee(node);
    };

    _Class.prototype.Identifier = function(node) {
      return this.escapeUndefined(node);
    };

    _Class.prototype.UnaryExpression = function(node) {
      this.braceObjectBesideUnary(node);
      return this.updateVoidToUndefined(node);
    };

    _Class.prototype.VariableDeclarator = function(node) {
      this.preventReservedWords(node.id);
      this.addShadowingIfNeeded(node);
      return this.addExplicitUndefinedInitializer(node);
    };

    _Class.prototype.AssignmentExpression = function(node) {
      if (this.isReservedIdentifier(node.left)) {
        if (this.options.compat) {
          return this.escapeJs(node);
        } else {
          return this.preventReservedWords(node.left);
        }
      } else if (node.left.type === 'Identifier' && this.ctx.vars.indexOf(node.left.name) === -1) {
        if (this.options.compat) {
          return this.escapeJs(node);
        } else {
          this.warn(node, "Assignment of global variable '" + node.left.name + "'");
          return node;
        }
      } else {
        return node;
      }
    };

    _Class.prototype.ReturnStatement = function(node) {
      return this.parenthesizeObjectsInArgument(node);
    };

    _Class.prototype.braceObjectBesideUnary = function(node) {
      if (node.argument.type === 'ObjectExpression') {
        node.argument._braced = true;
      }
    };


    /*
     * Catch usage of reserved words (eg, `off = 2`)
     */

    _Class.prototype.preventReservedWords = function(node) {
      if (this.isReservedIdentifier(node)) {
        return this.syntaxError(node, "'" + node.name + "' is a reserved CoffeeScript keyword");
      }
    };

    _Class.prototype.isReservedIdentifier = function(node) {
      var name;
      name = node != null ? node.name : void 0;
      return name && ~reservedWords.indexOf(name);
    };


    /*
     * Ensures that a ReturnStatement with an object ('return {a:1}') has a braced
     * expression.
     */

    _Class.prototype.parenthesizeObjectsInArgument = function(node) {
      if (node.argument) {
        if (node.argument.type === 'ObjectExpression') {
          node.argument._braced = true;
        }
      }
      return node;
    };


    /*
     * Adds a `var x` shadowing statement when encountering shadowed variables.
     * (See specs/shadowing/var_shadowing)
     */

    _Class.prototype.addShadowingIfNeeded = function(node) {
      var name, statement;
      name = node.id.name;
      if (~this.ctx.vars.indexOf(name)) {
        this.warn(node, "Variable shadowing ('" + name + "') is not fully supported in CoffeeScript");
        statement = replace(node, {
          type: 'ExpressionStatement',
          expression: {
            type: 'CoffeeEscapedExpression',
            raw: "var " + name
          }
        });
        return this.scope.body = [statement].concat(this.scope.body);
      } else {
        return this.ctx.vars.push(name);
      }
    };


    /*
     * For VariableDeclarator with no initializers (`var a`), add `undefined` as
     * the initializer.
     */

    _Class.prototype.addExplicitUndefinedInitializer = function(node) {
      if (node.init == null) {
        node.init = {
          type: 'Identifier',
          name: 'undefined'
        };
        this.skip();
      }
      return node;
    };


    /*
     * Updates `void 0` UnaryExpressions to `undefined` Identifiers.
     */

    _Class.prototype.updateVoidToUndefined = function(node) {
      if (node.operator === 'void') {
        return replace(node, {
          type: 'Identifier',
          name: 'undefined'
        });
      } else {
        return node;
      }
    };


    /*
     * Turn 'undefined' into '`undefined`'. This uses a new node type,
     * CoffeeEscapedExpression.
     */

    _Class.prototype.escapeUndefined = function(node) {
      if (node.name === 'undefined' && this.options.compat) {
        return replace(node, {
          type: 'CoffeeEscapedExpression',
          raw: 'undefined'
        });
      } else {
        return node;
      }
    };


    /*
     * Removes `undefined` from function parameters.
     * (`function (a, undefined) {}` => `(a) ->`)
     */

    _Class.prototype.removeUndefinedParameter = function(node) {
      var i, isLast, isUndefined, j, len, param, ref1;
      if (node.params) {
        ref1 = node.params;
        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
          param = ref1[i];
          isLast = i === node.params.length - 1;
          isUndefined = param.type === 'Identifier' && param.name === 'undefined';
          if (isUndefined) {
            if (isLast) {
              node.params.pop();
            } else {
              this.syntaxError(param, "'undefined' is not allowed in function parameters");
            }
          }
        }
      }
      return node;
    };


    /*
     * In an IIFE, ensure that the function expression is parenthesized (eg,
     * `(($)-> x) jQuery`).
     */

    _Class.prototype.parenthesizeCallee = function(node) {
      if (node.callee.type === 'FunctionExpression') {
        node.callee._parenthesized = true;
        return node;
      }
    };

    return _Class;

  })(TransformerBase);

}).call(this);

//# sourceMappingURL=others.js.map
