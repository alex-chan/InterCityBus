// Generated by CoffeeScript 1.10.0
(function() {
  var TransformerBase, getPrecedence, isIntransitiveDivision, isIntransitiveSubtraction, isOperation, nonTailingTernary,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  getPrecedence = require('../helpers').getPrecedence;

  TransformerBase = require('./base');


  /*
   * Fixes operator precedences
   */

  module.exports = (function(superClass) {
    extend(_Class, superClass);

    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.onEnter = function(node, parent) {
      var parenthesize, prec, type;
      if (!parent) {
        return;
      }
      type = parent.type;
      if (type === 'CallExpression' && parent["arguments"].indexOf(node) > -1) {
        return;
      }
      if (type === 'NewExpression' && parent["arguments"].indexOf(node) > -1) {
        return;
      }
      if (type === 'MemberExpression' && parent.property === node) {
        return;
      }
      prec = getPrecedence(node);
      if (prec === -1) {
        return;
      }
      parenthesize = isIntransitiveSubtraction(parent, node) || isIntransitiveDivision(parent, node) || nonTailingTernary(parent, node) || prec < getPrecedence(parent);
      if (parenthesize) {
        return node._parenthesized = true;
      }
    };

    return _Class;

  })(TransformerBase);

  isIntransitiveSubtraction = function(parent, node) {
    return isOperation(parent, '-') && parent.right === node;
  };

  isIntransitiveDivision = function(parent, node) {
    return isOperation(parent, '/') && (isOperation(node, '/') || isOperation(node, '*')) && parent.right === node;
  };

  isOperation = function(node, op) {
    return node.type === 'BinaryExpression' && node.operator === op;
  };

  nonTailingTernary = function(parent, node) {
    return parent.type === 'ConditionalExpression' && node.type === 'ConditionalExpression' && parent.alternate !== node;
  };

}).call(this);

//# sourceMappingURL=precedence.js.map
