// Generated by CoffeeScript 1.10.0
(function() {
  var crypto, validatePresenceOf;

  crypto = require("crypto");

  validatePresenceOf = function(value) {
    return value && value.length;
  };

  module.exports = function(sequelize, DataType) {
    var User;
    User = sequelize.define('_user', {
      id: {
        type: DataType.INTEGER,
        allowNull: false,
        autoIncrement: true,
        primaryKey: true
      },
      name: DataType.STRING,
      phoneNumber: DataType.STRING,
      email: {
        type: DataType.STRING,
        unique: {
          msg: '这个email已经被使用'
        },
        validate: {
          isEmail: true
        }
      },
      role: {
        type: DataType.STRING,
        defaultValue: 'user'
      },
      password: {
        type: DataType.STRING,
        validate: {
          notEmpty: true
        }
      },
      provier: DataType.STRING,
      salt: DataType.STRING,
      regIP: DataType.STRING
    }, {
      getterMethods: {
        profile: function() {
          return {
            name: this.name,
            role: this.role
          };
        },
        token: function() {
          return {
            id: this.id,
            role: this.role
          };
        }
      },
      hooks: {
        beforeBulkCreate: function(users, fields, fn) {
          var totalUpdated;
          totalUpdated = 0;
          return users.forEach(function(user) {
            if (err) {
              return fn(err);
            }
            totalUpdated += 1;
            if (totalUpdated === users.length) {
              return fn();
            }
          });
        },
        beforeCreate: function(user, fields, fn) {
          return user.updatePassword(fn);
        },
        beforeUpdate: function(user, fields, fn) {
          if (user.changed('password')) {
            return user.updatePassword(fn);
          }
          return fn();
        }
      },
      instanceMethods: {

        /*
           * Authenticate - check if the passwords are the same
           *
           * @param {String} password
           * @param {Function} callback
           * @return {Boolean}
           * @api public
         */
        authenticate: function(password, callback) {
          var self;
          if (!callback) {
            return this.password === this.encryptPassword(password);
          }
          self = this;
          return this.encryptPassword(password, function(err, pswGen) {
            if (err) {
              callback(err);
            }
            if (self.password === pswGen) {
              return callback(null, true);
            } else {
              return callback(null, false);
            }
          });
        },

        /*
           * Make salt
           *
           * @param {Number} byteSize Optional salt byte size, default to 16
           * @param {Function} callback
           * @return {String}
           * @api public
         */
        makeSalt: function(byteSize, callback) {
          var defaultByteSize;
          defaultByteSize = 16;
          if (typeof arguments[0] === 'function') {
            callback = arguments[0];
            byteSize = defaultByteSize;
          } else if (typeof arguments[1] === 'function') {
            callback = arguments[1];
          }
          if (!byteSize) {
            byteSize = defaultByteSize;
          }
          if (!callback) {
            return crypto.randomBytes(byteSize).toString('base64');
          }
          return crypto.randomBytes(byteSize, function(err, salt) {
            if (err) {
              callback(err);
            }
            return callback(null, salt.toString('base64'));
          });
        },

        /*
        * Encrypt password
        *
        * @param {String} password
        * @param {Function} callback
        * @return {String}
        * @api public
         */
        encryptPassword: function(password, callback) {
          var defaultIterations, defaultKeyLength, salt;
          if (!password || !this.salt) {
            if (!callback) {
              return null;
            }
            return callback(null);
          }
          defaultIterations = 10001;
          defaultKeyLength = 64;
          salt = new Buffer(this.salt, 'base64');
          if (!callback) {
            return crypto.pbkdf2Sync(password, salt, defaultIterations, defaultKeyLength).toString('base64');
          }
          return crypto.pbkdf2Sync(password, salt, defaultIterations, defaultKeyLength, function(err, key) {
            if (err) {
              callback(err);
            }
            return callback(null, key.toString('base64'));
          });
        },

        /*
           * Update password field
           *
           * @param {Function} fn
           * @return {String}
           * @api public
         */
        updatePassword: function(fn) {
          var self;
          if (this.password) {
            if (!validatePresenceOf(this.password)) {
              return fn(new Error('Invalid password'));
            }
            self = this;
            return this.makeSalt(function(saltErr, salt) {
              if (saltErr) {
                return fn(saltErr);
              }
              self.salt = salt;
              return self.encryptPassword(self.password, function(encryptErr, hashedPassword) {
                if (encryptErr) {
                  return fn(encryptErr);
                }
                self.password = hashedPassword;
                return fn(null);
              });
            });
          } else {
            return fn(null);
          }
        }
      }
    });
    return User;
  };

}).call(this);

//# sourceMappingURL=user.model.js.map
